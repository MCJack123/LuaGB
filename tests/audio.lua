describe("Audio", function()
  describe("DividingTimer", function()
    setup(function()
      DividingTimer = require("gameboy/audio/dividing_timer")
    end)
    it("can be created", function()
      local timer = DividingTimer:new()
      assert.are_not_same(timer, nil)
    end)
    it("period can be set", function()
      local timer = DividingTimer:new()
      timer:setPeriod(10)
      assert.are_same(timer:period(), 10)
    end)
    it("uses the current period when reloaded with no arguments", function()
      local timer = DividingTimer:new()
      timer:setPeriod(10)
      timer:reload()
      assert.are_same(timer:remainingClocks(), 10)
    end)
    it("can be reloaded with an argument to also set the period", function()
      local timer = DividingTimer:new()
      timer:reload(20)
      assert.are_same(timer:period(), 20)
      assert.are_same(timer:remainingClocks(), 20)
    end)
    it("can be clocked once", function()
      local timer = DividingTimer:new()
      timer:reload(10)      
      timer:clock()
      assert.are_same(timer:remainingClocks(), 9)
    end)
    it("single clocks can reset the timer", function()
      local timer = DividingTimer:new()
      -- set the initial period to 1, so the next clock resets
      timer:reload(1) 
      -- set the period to higher than 1, so we can detect the
      -- change. We do this because a period of 1 should reset
      -- back to one after a single clock, which we can't
      -- detect.
      timer:setPeriod(10)
      assert.are_same(timer:remainingClocks(), 1)
      timer:clock()
      assert.are_same(timer:remainingClocks(), 10)
    end)
    it("can be advanced multiple clocks", function()
      local timer = DividingTimer:new()
      timer:reload(10)
      -- advances multiple clocks at once
      timer:advance(5)
      assert.are_same(timer:remainingClocks(), 5)
    end)
    it("advancing multiple clocks can reset the timer", function()
      local timer = DividingTimer:new()
      timer:reload(5)
      -- Again, set the period to be different than the current period,
      -- so we can detect that a reset occurred
      timer:setPeriod(10)
      timer:advance(5)
      assert.are_same(timer:remainingClocks(), 10)
    end)
    it("setPeriod does not affect remaining clocks", function()
      local timer = DividingTimer:new()
      timer:reload(10)
      timer:clock()
      timer:setPeriod(20)
      assert.are_same(timer:remainingClocks(), 9)
    end)
    it("work is performed when the timer resets", function()
      local work = spy.new(function() end)
      local timer = DividingTimer:new()
      timer:onReset(work) -- spy on timer resets
      timer:reload(10)
      timer:advance(10)
      assert.spy(work).was.called()
    end)
    it("advancing multiple periods performs work multiple times", function()
      local work = spy.new(function() end)
      local timer = DividingTimer:new()
      timer:onReset(work) -- spy on timer resets
      timer:reload(10)
      timer:advance(20)
      assert.spy(work).was.called(2) -- twice
    end)
    it("advancing through a reset handles remainder correctly", function()
      local timer = DividingTimer:new()
      timer:reload(10)
      timer:advance(15)
      assert.are_same(timer:remainingClocks(), 5)
    end)
  end)
  describe("SquareWaveGenerator", function()
    setup(function()
      SquareWaveGenerator = require("gameboy/audio/square_wave_generator")
    end)
    it("can be created", function()
      square = SquareWaveGenerator:new()
      assert.are_not_same(square, nil)
    end)
    it("waveform can be set", function()
      local square = SquareWaveGenerator:new()
      square:setWaveform(0x0F)
      assert.are_same(square:waveform(), 0x0F)
    end)
    it("output is based on the low bit of the selected waveform", function()
      local square = SquareWaveGenerator:new()
      square:setWaveform(0x0F)
      assert.are_same(square:output(), 1)
      square:setWaveform(0xF0)
      assert.are_same(square:output(), 0)
    end)
    it("clocks rotate the waveform", function()
      local square = SquareWaveGenerator:new()
      square:setWaveform(0x01)
      square:clock()
      assert.are_same(square:waveform(), 0x80)
      square:clock()
      assert.are_same(square:waveform(), 0x40)
    end)
    it("the waveform is clocked when the timer expires", function()
      local square = SquareWaveGenerator:new()
      square:setWaveform(0x01)
      square.timer:reload(10)
      square.timer:advance(10)
      assert.are_same(square:waveform(), 0x80)
    end)
  end)
  describe("VolumeEnvelope", function()
    setup(function()
      VolumeEnvelope = require("gameboy/audio/volume_envelope")
    end)
    it("can be created", function()
      envelope = VolumeEnvelope:new()
      assert.are_not_same(envelope, nil)
    end)
    it("applies adjustment to volume when clocked", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(7)
      envelope:setAdjustment(1)
      envelope:clock()
      assert.are_same(8, envelope:volume())
    end)
    it("volume must not exceed 15", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(15)
      envelope:setAdjustment(1)
      envelope:clock()
      assert.are_same(15, envelope:volume())
    end)
    it("volume must remain >= 0", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(0)
      envelope:setAdjustment(-1)
      envelope:clock()
      assert.are_same(0, envelope:volume())
    end)
    it("dividing timer adjusts volume when clocked", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(7)
      envelope:setAdjustment(1)
      envelope.timer:reload(10)
      envelope.timer:advance(10)
      assert.are_same(8, envelope:volume())
    end)
    it("GB quirk: volume is NOT adjusted if timer period == 8", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(7)
      envelope:setAdjustment(1)
      envelope.timer:reload(8)
      envelope.timer:advance(8)
      assert.are_same(7, envelope:volume())
      envelope:clock()
      assert.are_same(7, envelope:volume())
    end)
    it("output waveform is one of 0 or current volume", function()
      envelope = VolumeEnvelope:new()
      envelope:setVolume(7)
      assert.are_same(0, envelope:output(0))
      assert.are_same(7, envelope:output(1))
    end)
  end)
  describe("Registers", function()
    setup(function()
      -- Create a mock audio module with stubbed out external modules
      Audio = require("gameboy/audio/init")
      Io = require("gameboy/io")
      Memory = require("gameboy/memory")
      Timers = require("gameboy/timers")
      bit32 = require("bit")
    end)
    before_each(function()
      local modules = {}
      modules.memory = Memory.new()
      modules.io = Io.new(modules)
      modules.timers = Timers.new(modules)
      audio = Audio.new(modules)
      -- create a non-local io reference, to mock writes in tests
      io = modules.io
      ports = io.ports
      timers = modules.timers
    end)
    it("mock audio module can be created", function()
      assert.not_same(audio, nil)
    end)
    describe("Tone 1", function()
      it("isolated writes to NR13 set period", function()
        audio.tone1.generator.timer:setPeriod(0)
        io.write_logic[ports.NR13](0xFF)
        assert.are_same((2048 - 0x00FF) * 4, audio.tone1.generator.timer:period())
      end)
      it("isolated writes to NR13 set period", function()
        audio.tone1.generator.timer:setPeriod(0)
        io.write_logic[ports.NR14](0x07)
        assert.are_same((2048 - 0x0700) * 4, audio.tone1.generator.timer:period())
      end)
      it("writes to NR14 use the low bits from NR13 for the period", function()
        -- Make sure writes to each of the low / high byte use the value from the other half:
        audio.tone1.generator.timer:setPeriod(0)
        io.write_logic[ports.NR13](0x22)
        io.write_logic[ports.NR14](0x01)
        assert.are_same((2048 - 0x0122) * 4, audio.tone1.generator.timer:period())
      end)
      it("writes to NR13 use the high bits from NR14 for the period", function()
        audio.tone1.generator.timer:setPeriod(0)
        io.write_logic[ports.NR14](0x03)
        io.write_logic[ports.NR13](0x44)
        assert.are_same((2048 - 0x0344) * 4, audio.tone1.generator.timer:period())
      end)
      it("writes to NR11 set the waveform duty", function()
        audio.tone1.generator:setWaveform(0x00)
        io.write_logic[ports.NR11](bit32.lshift(0x0, 6))
        assert.are_same(0x01, audio.tone1.generator:waveform())
        io.write_logic[ports.NR11](bit32.lshift(0x1, 6))
        assert.are_same(0x81, audio.tone1.generator:waveform())
        io.write_logic[ports.NR11](bit32.lshift(0x2, 6))
        assert.are_same(0x87, audio.tone1.generator:waveform())
        io.write_logic[ports.NR11](bit32.lshift(0x3, 6))
        assert.are_same(0x7E, audio.tone1.generator:waveform())
      end)
      it("writes to NR12 set the current volume", function()
        audio.tone1.volume_envelope:setVolume(0)
        io.write_logic[ports.NR12](0x70)
        io.write_logic[ports.NR14](0x80) -- trigger a new note
        assert.are_same(0x7, audio.tone1.volume_envelope:volume())
      end)
      it("writes to NR12 set the volume adjustment", function()
        audio.tone1.volume_envelope:setAdjustment(0)
        io.write_logic[ports.NR12](0x08)
        io.write_logic[ports.NR14](0x80) -- trigger a new note
        assert.are_same(1, audio.tone1.volume_envelope:adjustment())
        io.write_logic[ports.NR12](0x00)
        io.write_logic[ports.NR14](0x80) -- trigger a new note
        assert.are_same(-1, audio.tone1.volume_envelope:adjustment())
      end)
      it("writes to NR12 set the volume envelope period", function()
        audio.tone1.volume_envelope.timer:setPeriod(0)
        io.write_logic[ports.NR12](0x07)
        io.write_logic[ports.NR14](0x80) -- trigger a new note
        assert.are_same(7, audio.tone1.volume_envelope.timer:period())
      end)
      it("GB quirk: writes to NR12 treat a period of 0 as 8 instead", function()
        audio.tone1.volume_envelope.timer:setPeriod(0)
        io.write_logic[ports.NR12](0x00)
        io.write_logic[ports.NR14](0x80) -- trigger a new note
        assert.are_same(8, audio.tone1.volume_envelope.timer:period())
      end)
    end)
    describe("Tone 2", function()
      it("isolated writes to NR23 set period", function()
        audio.tone2.generator.timer:setPeriod(0)
        io.write_logic[ports.NR23](0xFF)
        assert.are_same((2048 - 0x00FF) * 4, audio.tone2.generator.timer:period())
      end)
      it("isolated writes to NR23 set period", function()
        audio.tone2.generator.timer:setPeriod(0)
        io.write_logic[ports.NR24](0x07)
        assert.are_same((2048 - 0x0700) * 4, audio.tone2.generator.timer:period())
      end)
      it("writes to NR24 use the low bits from NR23 for the period", function()
        -- Make sure writes to each of the low / high byte use the value from the other half:
        audio.tone2.generator.timer:setPeriod(0)
        io.write_logic[ports.NR23](0x22)
        io.write_logic[ports.NR24](0x01)
        assert.are_same((2048 - 0x0122) * 4, audio.tone2.generator.timer:period())
      end)
      it("writes to NR23 use the high bits from NR24 for the period", function()
        audio.tone2.generator.timer:setPeriod(0)
        io.write_logic[ports.NR24](0x03)
        io.write_logic[ports.NR23](0x44)
        assert.are_same((2048 - 0x0344) * 4, audio.tone2.generator.timer:period())
      end)
      it("writes to NR21 set the waveform duty", function()
        audio.tone2.generator:setWaveform(0x00)
        io.write_logic[ports.NR21](bit32.lshift(0x0, 6))
        assert.are_same(0x01, audio.tone2.generator:waveform())
        io.write_logic[ports.NR21](bit32.lshift(0x1, 6))
        assert.are_same(0x81, audio.tone2.generator:waveform())
        io.write_logic[ports.NR21](bit32.lshift(0x2, 6))
        assert.are_same(0x87, audio.tone2.generator:waveform())
        io.write_logic[ports.NR21](bit32.lshift(0x3, 6))
        assert.are_same(0x7E, audio.tone2.generator:waveform())
      end)
      it("writes to NR22 set the current volume", function()
        audio.tone2.volume_envelope:setVolume(0)
        io.write_logic[ports.NR22](0x70)
        io.write_logic[ports.NR24](0x80) -- trigger a new note
        assert.are_same(0x7, audio.tone2.volume_envelope:volume())
      end)
      it("writes to NR22 set the volume adjustment", function()
        audio.tone2.volume_envelope:setAdjustment(0)
        io.write_logic[ports.NR22](0x08)
        io.write_logic[ports.NR24](0x80) -- trigger a new note
        assert.are_same(1, audio.tone2.volume_envelope:adjustment())
        io.write_logic[ports.NR22](0x00)
        io.write_logic[ports.NR24](0x80) -- trigger a new note
        assert.are_same(-1, audio.tone2.volume_envelope:adjustment())
      end)
      it("writes to NR22 set the volume envelope period", function()
        audio.tone2.volume_envelope.timer:setPeriod(0)
        io.write_logic[ports.NR22](0x07)
        io.write_logic[ports.NR24](0x80) -- trigger a new note
        assert.are_same(7, audio.tone2.volume_envelope.timer:period())
      end)
      it("GB quirk: writes to NR22 treat a period of 0 as 8 instead", function()
        audio.tone2.volume_envelope.timer:setPeriod(0)
        io.write_logic[ports.NR22](0x00)
        io.write_logic[ports.NR24](0x80) -- trigger a new note
        assert.are_same(8, audio.tone2.volume_envelope.timer:period())
      end)
    end)
  end)
end)